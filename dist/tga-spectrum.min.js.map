{"version":3,"file":"tga-spectrum.min.js","sources":["../node_modules/is-any-array/src/index.js","../node_modules/ml-array-sequential-fill/lib-es6/index.js","../node_modules/ml-zones/src/normalize.js","../node_modules/ml-array-xy-equally-spaced/src/integral.js","../node_modules/ml-array-xy-equally-spaced/src/index.js","../node_modules/ml-zones/src/invert.js","../node_modules/ml-zones/src/zonesWithPoints.js","../node_modules/ml-array-xy-equally-spaced/src/equallySpacedSlot.js","../node_modules/ml-array-xy-equally-spaced/src/equallySpacedSmooth.js","../node_modules/ml-stat/array.js","../node_modules/ml-array-normed/node_modules/is-any-array/src/index.js","../node_modules/.pnpm/registry.npmjs.org/is-any-array/0.0.3/node_modules/is-any-array/src/index.js","../node_modules/.pnpm/registry.npmjs.org/ml-array-max/1.1.2/node_modules/ml-array-max/lib-es6/index.js","../node_modules/ml-array-sum/lib-es6/index.js","../node_modules/ml-array-normed/lib-es6/index.js","../node_modules/.pnpm/registry.npmjs.org/ml-array-min/1.1.2/node_modules/ml-array-min/lib-es6/index.js","../node_modules/ml-array-rescale/lib-es6/index.js","../node_modules/ml-array-xy-filter-x/src/index.js","../node_modules/ml-array-xy-filter-x/src/getZones.js","../src/Spectrum.js","../src/util/getNormalized.js","../src/from/parsePerkinElmer.js","../node_modules/jcampconverter/src/complexChromatogram.js","../node_modules/jcampconverter/src/convertToFloatArray.js","../node_modules/jcampconverter/src/parse/fastParseXYData.js","../node_modules/jcampconverter/src/parse/parsePeakTable.js","../node_modules/jcampconverter/src/parse/parseXYA.js","../node_modules/median-quickselect/lib/median-quickselect.min.js","../node_modules/ml-array-median/lib-es6/index.js","../node_modules/jcampconverter/src/2d/add2D.js","../node_modules/jcampconverter/src/2d/convertTo3DZ.js","../node_modules/jcampconverter/src/2d/generateContourLines.js","../node_modules/jcampconverter/src/profiling.js","../node_modules/jcampconverter/src/simpleChromatogram.js","../node_modules/jcampconverter/src/prepareSpectrum.js","../node_modules/jcampconverter/src/convert.js","../node_modules/jcampconverter/src/postProcessing.js","../node_modules/.pnpm/registry.npmjs.org/ml-xy-convert/1.0.0/node_modules/ml-xy-convert/src/from.js","../node_modules/.pnpm/registry.npmjs.org/ml-xy-convert/1.0.0/node_modules/ml-xy-convert/src/index.js","../node_modules/.pnpm/registry.npmjs.org/ml-xy-convert/1.0.0/node_modules/ml-xy-convert/src/to.js","../node_modules/.pnpm/registry.npmjs.org/convert-to-jcamp/2.0.1/node_modules/convert-to-jcamp/src/index.js","../node_modules/.pnpm/registry.npmjs.org/convert-to-jcamp/2.0.1/node_modules/convert-to-jcamp/src/creator.js","../src/to/toJcamp.js","../src/jsgraph/addStyle.js","../src/Spectra.js","../src/from/fromJcamp.js","../src/addJcamp.js","../src/from/fromPerkinElmer.js","../src/jsgraph/getJSGraph.js"],"sourcesContent":["'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","import isArray from 'is-any-array';\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/**\n * Fill an array with sequential numbers\n * @param {Array<number>} [input] - optional destination array (if not provided a new array will be created)\n * @param {object} [options={}]\n * @param {number} [options.from=0] - first value in the array\n * @param {number} [options.to=10] - last value in the array\n * @param {number} [options.size=input.length] - size of the array (if not provided calculated from step)\n * @param {number} [options.step] - if not provided calculated from size\n * @return {Array<number>}\n */\n\nfunction sequentialFill() {\n  var input = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (_typeof(input) === 'object' && !isArray(input)) {\n    options = input;\n    input = [];\n  }\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  var _options = options,\n      _options$from = _options.from,\n      from = _options$from === void 0 ? 0 : _options$from,\n      _options$to = _options.to,\n      to = _options$to === void 0 ? 10 : _options$to,\n      _options$size = _options.size,\n      size = _options$size === void 0 ? input.length : _options$size,\n      step = _options.step;\n\n  if (size && step) {\n    throw new Error('step is defined by the array size');\n  }\n\n  if (!size) {\n    if (step) {\n      size = Math.floor((to - from) / step) + 1;\n    } else {\n      size = to - from + 1;\n    }\n  }\n\n  if (!step && size) {\n    step = (to - from) / (size - 1);\n  }\n\n  if (Array.isArray(input)) {\n    input.length = 0; // only works with normal array\n\n    for (var i = 0; i < size; i++) {\n      input.push(from);\n      from += step;\n    }\n  } else {\n    if (input.length !== size) {\n      throw new Error('sequentialFill typed array must have the correct length');\n    }\n\n    for (var _i = 0; _i < size; _i++) {\n      input[_i] = from;\n      from += step;\n    }\n  }\n\n  return input;\n}\n\nexport default sequentialFill;\n","/**\n * Normalize an array of zones:\n * - ensure than from < to\n * - merge overlapping zones\n *\n * The method will always check if from if lower than to and will swap if required.\n * @param {Array} [zones=[]]\n * @param {object} [options={}]\n * @param {number} [options.from=Number.NEGATIVE_INFINITY] Specify min value of a zone\n * @param {number} [options.to=Number.POSITIVE_INFINITY] Specify max value of a zone\n */\n\nexport function normalize(zones = [], options = {}) {\n  if (zones.length === 0) return [];\n  let {\n    from = Number.NEGATIVE_INFINITY,\n    to = Number.POSITIVE_INFINITY,\n  } = options;\n  if (from > to) [from, to] = [to, from];\n\n  zones = JSON.parse(JSON.stringify(zones)).map((zone) =>\n    zone.from > zone.to ? { from: zone.to, to: zone.from } : zone,\n  );\n  zones = zones.sort((a, b) => {\n    if (a.from !== b.from) return a.from - b.from;\n    return a.to - b.to;\n  });\n\n  zones.forEach((zone) => {\n    if (from > zone.from) zone.from = from;\n    if (to < zone.to) zone.to = to;\n  });\n\n  zones = zones.filter((zone) => zone.from <= zone.to);\n  if (zones.length === 0) return [];\n\n  let currentZone = zones[0];\n  let result = [currentZone];\n  for (let i = 1; i < zones.length; i++) {\n    let zone = zones[i];\n    if (zone.from <= currentZone.to) {\n      currentZone.to = zone.to;\n    } else {\n      currentZone = zone;\n      result.push(currentZone);\n    }\n  }\n  return result;\n}\n","/**\n * Function that calculates the integral of the line between two\n * x-coordinates, given the slope and intercept of the line.\n * @param {number} x0\n * @param {number} x1\n * @param {number} slope\n * @param {number} intercept\n * @return {number} integral value.\n */\nexport default function integral(x0, x1, slope, intercept) {\n  return (\n    0.5 * slope * x1 * x1 +\n    intercept * x1 -\n    (0.5 * slope * x0 * x0 + intercept * x0)\n  );\n}\n","import sequentialFill from 'ml-array-sequential-fill';\nimport { zonesWithPoints, invert } from 'ml-zones';\n\nimport equallySpacedSmooth from './equallySpacedSmooth';\nimport equallySpacedSlot from './equallySpacedSlot';\n\n/**\n * Function that returns a Number array of equally spaced numberOfPoints\n * containing a representation of intensities of the spectra arguments x\n * and y.\n *\n * The options parameter contains an object in the following form:\n * from: starting point\n * to: last point\n * numberOfPoints: number of points between from and to\n * variant: \"slot\" or \"smooth\" - smooth is the default option\n *\n * The slot variant consist that each point in the new array is calculated\n * averaging the existing points between the slot that belongs to the current\n * value. The smooth variant is the same but takes the integral of the range\n * of the slot and divide by the step size between two points in the new array.\n *\n * If exclusions zone are present, zones are ignored !\n * @param {object} [arrayXY={}] - object containing 2 properties x and y (both an array)\n * @param {object} [options={}]\n * @param {number} [options.from=x[0]]\n * @param {number} [options.to=x[x.length-1]]\n * @param {string} [options.variant='smooth']\n * @param {number} [options.numberOfPoints=100]\n * @param {Array} [options.exclusions=[]] array of from / to that should be skipped for the generation of the points\n * @param {Array} [options.zones=[]] array of from / to that should be kept\n * @return {object<x: Array, y:Array>} new object with x / y array with the equally spaced data.\n */\n\nexport default function equallySpaced(arrayXY = {}, options = {}) {\n  let { x, y } = arrayXY;\n  let xLength = x.length;\n  let reverse = false;\n  if (x.length > 1 && x[0] > x[1]) {\n    x = x.slice().reverse();\n    y = y.slice().reverse();\n    reverse = true;\n  }\n\n  let {\n    from = x[0],\n    to = x[xLength - 1],\n    variant = 'smooth',\n    numberOfPoints = 100,\n    exclusions = [],\n    zones = [],\n  } = options;\n\n  if (xLength !== y.length) {\n    throw new RangeError(\"the x and y vector doesn't have the same size.\");\n  }\n\n  if (typeof from !== 'number' || isNaN(from)) {\n    throw new RangeError(\"'from' option must be a number\");\n  }\n\n  if (typeof to !== 'number' || isNaN(to)) {\n    throw new RangeError(\"'to' option must be a number\");\n  }\n\n  if (typeof numberOfPoints !== 'number' || isNaN(numberOfPoints)) {\n    throw new RangeError(\"'numberOfPoints' option must be a number\");\n  }\n\n  if (numberOfPoints < 2) {\n    throw new RangeError(\"'numberOfPoints' option must be greater than 1\");\n  }\n\n  if (zones.length === 0) {\n    zones = invert(exclusions, { from, to });\n  }\n\n  zones = zonesWithPoints(zones, numberOfPoints, { from, to });\n\n  let xResult = [];\n  let yResult = [];\n  for (let zone of zones) {\n    let zoneResult = processZone(\n      x,\n      y,\n      zone.from,\n      zone.to,\n      zone.numberOfPoints,\n      variant,\n      reverse,\n    );\n\n    xResult = xResult.concat(zoneResult.x);\n    yResult = yResult.concat(zoneResult.y);\n  }\n  if (reverse) {\n    if (from < to) {\n      return { x: xResult.reverse(), y: yResult.reverse() };\n    } else {\n      return { x: xResult, y: yResult };\n    }\n  } else {\n    if (from < to) {\n      return { x: xResult, y: yResult };\n    } else {\n      return { x: xResult.reverse(), y: yResult.reverse() };\n    }\n  }\n}\n\nfunction processZone(x, y, from, to, numberOfPoints, variant) {\n  if (numberOfPoints < 1) {\n    throw new RangeError('the number of points must be at least 1');\n  }\n\n  let output =\n    variant === 'slot'\n      ? equallySpacedSlot(x, y, from, to, numberOfPoints)\n      : equallySpacedSmooth(x, y, from, to, numberOfPoints);\n\n  return {\n    x: sequentialFill({\n      from,\n      to,\n      size: numberOfPoints,\n    }),\n    y: output,\n  };\n}\n","import { normalize } from './normalize';\n\n/**\n * Convert an array of exclusions and keep only from / to\n *\n * The method will always check if from if lower than to and will swap if required.\n * @param {Array} [exclusions=[]]\n * @param {object} [options={}]\n * @param {number} [options.from=Number.NEGATIVE_INFINITY] Specify min value of zones (after inversion)\n * @param {number} [options.to=Number.POSITIVE_INFINITY] Specify max value of zones (after inversion)\n */\n\nexport function invert(exclusions = [], options = {}) {\n  let {\n    from = Number.NEGATIVE_INFINITY,\n    to = Number.POSITIVE_INFINITY,\n  } = options;\n  if (from > to) [from, to] = [to, from];\n\n  exclusions = normalize(exclusions, { from, to });\n  if (exclusions.length === 0) return [{ from, to }];\n\n  let zones = [];\n  for (let i = 0; i < exclusions.length; i++) {\n    let exclusion = exclusions[i];\n    let nextExclusion = exclusions[i + 1];\n    if (i === 0) {\n      if (exclusion.from > from) {\n        zones.push({ from, to: exclusion.from });\n      }\n    }\n    if (i === exclusions.length - 1) {\n      if (exclusion.to < to) {\n        zones.push({ from: exclusion.to, to });\n      }\n    } else {\n      zones.push({ from: exclusion.to, to: nextExclusion.from });\n    }\n  }\n\n  return zones;\n}\n","import { normalize } from './normalize';\n\n/**\n * Add the number of points per zone to reach a specified total\n * @param {Array} [zones=[]]\n * @param {number} [numberOfPoints] Total number of points to distribute between zones\n * @param {object} [options={}]\n * @param {number} [options.from=Number.NEGATIVE_INFINITY] Specify min value of a zone\n * @param {number} [options.to=Number.POSITIVE_INFINITY] Specify max value of a zone\n */\n\nexport function zonesWithPoints(zones, numberOfPoints, options = {}) {\n  if (zones.length === 0) return zones;\n  zones = normalize(zones, options);\n\n  const totalSize = zones.reduce((previous, current) => {\n    return previous + (current.to - current.from);\n  }, 0);\n\n  let unitsPerPoint = totalSize / numberOfPoints;\n  let currentTotal = 0;\n  for (let i = 0; i < zones.length - 1; i++) {\n    let zone = zones[i];\n    zone.numberOfPoints = Math.min(\n      Math.round((zone.to - zone.from) / unitsPerPoint),\n      numberOfPoints - currentTotal,\n    );\n    currentTotal += zone.numberOfPoints;\n  }\n\n  zones[zones.length - 1].numberOfPoints = numberOfPoints - currentTotal;\n\n  return zones;\n}\n","/**\n * function that retrieves the getEquallySpacedData with the variant \"slot\"\n *\n * @param {Array<number>} x\n * @param {Array<number>} y\n * @param {number} from - Initial point\n * @param {number} to - Final point\n * @param {number} numberOfPoints\n * @return {Array} - Array of y's equally spaced with the variant \"slot\"\n */\nexport default function equallySpacedSlot(x, y, from, to, numberOfPoints) {\n  let xLength = x.length;\n\n  let step = (to - from) / (numberOfPoints - 1);\n  let halfStep = step / 2;\n  let lastStep = x[x.length - 1] - x[x.length - 2];\n\n  let start = from - halfStep;\n  let output = new Array(numberOfPoints);\n\n  // Init main variables\n  let min = start;\n  let max = start + step;\n\n  let previousX = -Number.MAX_VALUE;\n  let previousY = 0;\n  let nextX = x[0];\n  let nextY = y[0];\n  let frontOutsideSpectra = 0;\n  let backOutsideSpectra = true;\n\n  let currentValue = 0;\n\n  // for slot algorithm\n  let currentPoints = 0;\n\n  let i = 1; // index of input\n  let j = 0; // index of output\n\n  main: while (true) {\n    if (previousX >= nextX) throw new Error('x must be an increasing serie');\n    while (previousX - max > 0) {\n      // no overlap with original point, just consume current value\n      if (backOutsideSpectra) {\n        currentPoints++;\n        backOutsideSpectra = false;\n      }\n\n      output[j] = currentPoints <= 0 ? 0 : currentValue / currentPoints;\n      j++;\n\n      if (j === numberOfPoints) {\n        break main;\n      }\n\n      min = max;\n      max += step;\n      currentValue = 0;\n      currentPoints = 0;\n    }\n\n    if (previousX > min) {\n      currentValue += previousY;\n      currentPoints++;\n    }\n\n    if (previousX === -Number.MAX_VALUE || frontOutsideSpectra > 1) {\n      currentPoints--;\n    }\n\n    previousX = nextX;\n    previousY = nextY;\n\n    if (i < xLength) {\n      nextX = x[i];\n      nextY = y[i];\n      i++;\n    } else {\n      nextX += lastStep;\n      nextY = 0;\n      frontOutsideSpectra++;\n    }\n  }\n\n  return output;\n}\n","import integral from './integral';\n\n/**\n * function that retrieves the getEquallySpacedData with the variant \"smooth\"\n *\n * @param {Array<number>} x\n * @param {Array<number>} y\n * @param {number} from - Initial point\n * @param {number} to - Final point\n * @param {number} numberOfPoints\n * @return {Array} - Array of y's equally spaced with the variant \"smooth\"\n */\nexport default function equallySpacedSmooth(x, y, from, to, numberOfPoints) {\n  let xLength = x.length;\n\n  let step = (to - from) / (numberOfPoints - 1);\n  let halfStep = step / 2;\n\n  let output = new Array(numberOfPoints);\n\n  let initialOriginalStep = x[1] - x[0];\n  let lastOriginalStep = x[xLength - 1] - x[xLength - 2];\n\n  // Init main variables\n  let min = from - halfStep;\n  let max = from + halfStep;\n\n  let previousX = Number.MIN_VALUE;\n  let previousY = 0;\n  let nextX = x[0] - initialOriginalStep;\n  let nextY = 0;\n\n  let currentValue = 0;\n  let slope = 0;\n  let intercept = 0;\n  let sumAtMin = 0;\n  let sumAtMax = 0;\n\n  let i = 0; // index of input\n  let j = 0; // index of output\n\n  function getSlope(x0, y0, x1, y1) {\n    return (y1 - y0) / (x1 - x0);\n  }\n\n  let add = 0;\n  main: while (true) {\n    if (previousX <= min && min <= nextX) {\n      add = integral(0, min - previousX, slope, previousY);\n      sumAtMin = currentValue + add;\n    }\n\n    while (nextX - max >= 0) {\n      // no overlap with original point, just consume current value\n      add = integral(0, max - previousX, slope, previousY);\n      sumAtMax = currentValue + add;\n\n      output[j++] = (sumAtMax - sumAtMin) / step;\n\n      if (j === numberOfPoints) {\n        break main;\n      }\n\n      min = max;\n      max += step;\n      sumAtMin = sumAtMax;\n    }\n\n    currentValue += integral(previousX, nextX, slope, intercept);\n\n    previousX = nextX;\n    previousY = nextY;\n\n    if (i < xLength) {\n      nextX = x[i];\n      nextY = y[i];\n      i++;\n    } else if (i === xLength) {\n      nextX += lastOriginalStep;\n      nextY = 0;\n    }\n\n    slope = getSlope(previousX, previousY, nextX, nextY);\n    intercept = -slope * previousX + previousY;\n  }\n\n  return output;\n}\n","'use strict';\n\nfunction compareNumbers(a, b) {\n    return a - b;\n}\n\n/**\n * Computes the sum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.sum = function sum(values) {\n    var sum = 0;\n    for (var i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum;\n};\n\n/**\n * Computes the maximum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.max = function max(values) {\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] > max) max = values[i];\n    }\n    return max;\n};\n\n/**\n * Computes the minimum of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.min = function min(values) {\n    var min = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n    }\n    return min;\n};\n\n/**\n * Computes the min and max of the given values\n * @param {Array} values\n * @returns {{min: number, max: number}}\n */\nexports.minMax = function minMax(values) {\n    var min = values[0];\n    var max = values[0];\n    var l = values.length;\n    for (var i = 1; i < l; i++) {\n        if (values[i] < min) min = values[i];\n        if (values[i] > max) max = values[i];\n    }\n    return {\n        min: min,\n        max: max\n    };\n};\n\n/**\n * Computes the arithmetic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.arithmeticMean = function arithmeticMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        sum += values[i];\n    }\n    return sum / l;\n};\n\n/**\n * {@link arithmeticMean}\n */\nexports.mean = exports.arithmeticMean;\n\n/**\n * Computes the geometric mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.geometricMean = function geometricMean(values) {\n    var mul = 1;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        mul *= values[i];\n    }\n    return Math.pow(mul, 1 / l);\n};\n\n/**\n * Computes the mean of the log of the given values\n * If the return value is exponentiated, it gives the same result as the\n * geometric mean.\n * @param {Array} values\n * @returns {number}\n */\nexports.logMean = function logMean(values) {\n    var lnsum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        lnsum += Math.log(values[i]);\n    }\n    return lnsum / l;\n};\n\n/**\n * Computes the weighted grand mean for a list of means and sample sizes\n * @param {Array} means - Mean values for each set of samples\n * @param {Array} samples - Number of original values for each set of samples\n * @returns {number}\n */\nexports.grandMean = function grandMean(means, samples) {\n    var sum = 0;\n    var n = 0;\n    var l = means.length;\n    for (var i = 0; i < l; i++) {\n        sum += samples[i] * means[i];\n        n += samples[i];\n    }\n    return sum / n;\n};\n\n/**\n * Computes the truncated mean of the given values using a given percentage\n * @param {Array} values\n * @param {number} percent - The percentage of values to keep (range: [0,1])\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.truncatedMean = function truncatedMean(values, percent, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var k = Math.floor(l * percent);\n    var sum = 0;\n    for (var i = k; i < (l - k); i++) {\n        sum += values[i];\n    }\n    return sum / (l - 2 * k);\n};\n\n/**\n * Computes the harmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.harmonicMean = function harmonicMean(values) {\n    var sum = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        if (values[i] === 0) {\n            throw new RangeError('value at index ' + i + 'is zero');\n        }\n        sum += 1 / values[i];\n    }\n    return l / sum;\n};\n\n/**\n * Computes the contraharmonic mean of the given values\n * @param {Array} values\n * @returns {number}\n */\nexports.contraHarmonicMean = function contraHarmonicMean(values) {\n    var r1 = 0;\n    var r2 = 0;\n    var l = values.length;\n    for (var i = 0; i < l; i++) {\n        r1 += values[i] * values[i];\n        r2 += values[i];\n    }\n    if (r2 < 0) {\n        throw new RangeError('sum of values is negative');\n    }\n    return r1 / r2;\n};\n\n/**\n * Computes the median of the given values\n * @param {Array} values\n * @param {boolean} [alreadySorted=false]\n * @returns {number}\n */\nexports.median = function median(values, alreadySorted) {\n    if (alreadySorted === undefined) alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n    var l = values.length;\n    var half = Math.floor(l / 2);\n    if (l % 2 === 0) {\n        return (values[half - 1] + values[half]) * 0.5;\n    } else {\n        return values[half];\n    }\n};\n\n/**\n * Computes the variance of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.variance = function variance(values, unbiased) {\n    if (unbiased === undefined) unbiased = true;\n    var theMean = exports.mean(values);\n    var theVariance = 0;\n    var l = values.length;\n\n    for (var i = 0; i < l; i++) {\n        var x = values[i] - theMean;\n        theVariance += x * x;\n    }\n\n    if (unbiased) {\n        return theVariance / (l - 1);\n    } else {\n        return theVariance / l;\n    }\n};\n\n/**\n * Computes the standard deviation of the given values\n * @param {Array} values\n * @param {boolean} [unbiased=true] - if true, divide by (n-1); if false, divide by n.\n * @returns {number}\n */\nexports.standardDeviation = function standardDeviation(values, unbiased) {\n    return Math.sqrt(exports.variance(values, unbiased));\n};\n\nexports.standardError = function standardError(values) {\n    return exports.standardDeviation(values) / Math.sqrt(values.length);\n};\n\n/**\n * IEEE Transactions on biomedical engineering, vol. 52, no. 1, january 2005, p. 76-\n * Calculate the standard deviation via the Median of the absolute deviation\n *  The formula for the standard deviation only holds for Gaussian random variables.\n * @returns {{mean: number, stdev: number}}\n */\nexports.robustMeanAndStdev = function robustMeanAndStdev(y) {\n    var mean = 0, stdev = 0;\n    var length = y.length, i = 0;\n    for (i = 0; i < length; i++) {\n        mean += y[i];\n    }\n    mean /= length;\n    var averageDeviations = new Array(length);\n    for (i = 0; i < length; i++)\n        averageDeviations[i] = Math.abs(y[i] - mean);\n    averageDeviations.sort(compareNumbers);\n    if (length % 2 === 1) {\n        stdev = averageDeviations[(length - 1) / 2] / 0.6745;\n    } else {\n        stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;\n    }\n\n    return {\n        mean: mean,\n        stdev: stdev\n    };\n};\n\nexports.quartiles = function quartiles(values, alreadySorted) {\n    if (typeof (alreadySorted) === 'undefined') alreadySorted = false;\n    if (!alreadySorted) {\n        values = [].concat(values).sort(compareNumbers);\n    }\n\n    var quart = values.length / 4;\n    var q1 = values[Math.ceil(quart) - 1];\n    var q2 = exports.median(values, true);\n    var q3 = values[Math.ceil(quart * 3) - 1];\n\n    return {q1: q1, q2: q2, q3: q3};\n};\n\nexports.pooledStandardDeviation = function pooledStandardDeviation(samples, unbiased) {\n    return Math.sqrt(exports.pooledVariance(samples, unbiased));\n};\n\nexports.pooledVariance = function pooledVariance(samples, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var sum = 0;\n    var length = 0, l = samples.length;\n    for (var i = 0; i < l; i++) {\n        var values = samples[i];\n        var vari = exports.variance(values);\n\n        sum += (values.length - 1) * vari;\n\n        if (unbiased)\n            length += values.length - 1;\n        else\n            length += values.length;\n    }\n    return sum / length;\n};\n\nexports.mode = function mode(values) {\n    var l = values.length,\n        itemCount = new Array(l),\n        i;\n    for (i = 0; i < l; i++) {\n        itemCount[i] = 0;\n    }\n    var itemArray = new Array(l);\n    var count = 0;\n\n    for (i = 0; i < l; i++) {\n        var index = itemArray.indexOf(values[i]);\n        if (index >= 0)\n            itemCount[index]++;\n        else {\n            itemArray[count] = values[i];\n            itemCount[count] = 1;\n            count++;\n        }\n    }\n\n    var maxValue = 0, maxIndex = 0;\n    for (i = 0; i < count; i++) {\n        if (itemCount[i] > maxValue) {\n            maxValue = itemCount[i];\n            maxIndex = i;\n        }\n    }\n\n    return itemArray[maxIndex];\n};\n\nexports.covariance = function covariance(vector1, vector2, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var mean1 = exports.mean(vector1);\n    var mean2 = exports.mean(vector2);\n\n    if (vector1.length !== vector2.length)\n        throw 'Vectors do not have the same dimensions';\n\n    var cov = 0, l = vector1.length;\n    for (var i = 0; i < l; i++) {\n        var x = vector1[i] - mean1;\n        var y = vector2[i] - mean2;\n        cov += x * y;\n    }\n\n    if (unbiased)\n        return cov / (l - 1);\n    else\n        return cov / l;\n};\n\nexports.skewness = function skewness(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n\n    var s2 = 0, s3 = 0, l = values.length;\n    for (var i = 0; i < l; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s3 += dev * dev * dev;\n    }\n    var m2 = s2 / l;\n    var m3 = s3 / l;\n\n    var g = m3 / (Math.pow(m2, 3 / 2.0));\n    if (unbiased) {\n        var a = Math.sqrt(l * (l - 1));\n        var b = l - 2;\n        return (a / b) * g;\n    } else {\n        return g;\n    }\n};\n\nexports.kurtosis = function kurtosis(values, unbiased) {\n    if (typeof (unbiased) === 'undefined') unbiased = true;\n    var theMean = exports.mean(values);\n    var n = values.length, s2 = 0, s4 = 0;\n\n    for (var i = 0; i < n; i++) {\n        var dev = values[i] - theMean;\n        s2 += dev * dev;\n        s4 += dev * dev * dev * dev;\n    }\n    var m2 = s2 / n;\n    var m4 = s4 / n;\n\n    if (unbiased) {\n        var v = s2 / (n - 1);\n        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));\n        var b = s4 / (v * v);\n        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));\n\n        return a * b - 3 * c;\n    } else {\n        return m4 / (m2 * m2) - 3;\n    }\n};\n\nexports.entropy = function entropy(values, eps) {\n    if (typeof (eps) === 'undefined') eps = 0;\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * Math.log(values[i] + eps);\n    return -sum;\n};\n\nexports.weightedMean = function weightedMean(values, weights) {\n    var sum = 0, l = values.length;\n    for (var i = 0; i < l; i++)\n        sum += values[i] * weights[i];\n    return sum;\n};\n\nexports.weightedStandardDeviation = function weightedStandardDeviation(values, weights) {\n    return Math.sqrt(exports.weightedVariance(values, weights));\n};\n\nexports.weightedVariance = function weightedVariance(values, weights) {\n    var theMean = exports.weightedMean(values, weights);\n    var vari = 0, l = values.length;\n    var a = 0, b = 0;\n\n    for (var i = 0; i < l; i++) {\n        var z = values[i] - theMean;\n        var w = weights[i];\n\n        vari += w * (z * z);\n        b += w;\n        a += w * w;\n    }\n\n    return vari * (b / (b * b - a));\n};\n\nexports.center = function center(values, inPlace) {\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n\n    var result = values;\n    if (!inPlace)\n        result = [].concat(values);\n\n    var theMean = exports.mean(result), l = result.length;\n    for (var i = 0; i < l; i++)\n        result[i] -= theMean;\n};\n\nexports.standardize = function standardize(values, standardDev, inPlace) {\n    if (typeof (standardDev) === 'undefined') standardDev = exports.standardDeviation(values);\n    if (typeof (inPlace) === 'undefined') inPlace = false;\n    var l = values.length;\n    var result = inPlace ? values : new Array(l);\n    for (var i = 0; i < l; i++)\n        result[i] = values[i] / standardDev;\n    return result;\n};\n\nexports.cumulativeSum = function cumulativeSum(array) {\n    var l = array.length;\n    var result = new Array(l);\n    result[0] = array[0];\n    for (var i = 1; i < l; i++)\n        result[i] = result[i - 1] + array[i];\n    return result;\n};\n","const toString = Object.prototype.toString;\n\nexport default function isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n","'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the maximum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction max(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var maxValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\nexport default max;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the mean of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction sum(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var sumValue = 0;\n\n  for (var i = 0; i < input.length; i++) {\n    sumValue += input[i];\n  }\n\n  return sumValue;\n}\n\nexport default sum;\n","import isArray from 'is-any-array';\nimport max from 'ml-array-max';\nimport sum from 'ml-array-sum';\n\n/**\n * Computes the norm of the given values\n * @param {Array<number>} input\n * @param {object} [options={}]\n * @param {string} [options.algorithm='absolute'] absolute, sum or max\n * @param {number} [options.maxValue=1] new max value for algo max\n * @param {Array} [options.output=[]] specify the output array, can be the input array for in place modification\n * @return {number}\n */\n\nfunction norm(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$algorithm = options.algorithm,\n      algorithm = _options$algorithm === void 0 ? 'absolute' : _options$algorithm,\n      _options$maxValue = options.maxValue,\n      maxValue = _options$maxValue === void 0 ? 1 : _options$maxValue;\n\n  if (!isArray(input)) {\n    throw new Error('input must be an array');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!isArray(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  if (input.length === 0) {\n    throw new Error('input must not be empty');\n  }\n\n  switch (algorithm.toLowerCase()) {\n    case 'absolute':\n      {\n        var absoluteSumValue = absoluteSum(input);\n        if (absoluteSumValue === 0) return input.slice(0);\n\n        for (var i = 0; i < input.length; i++) {\n          output[i] = input[i] / absoluteSumValue;\n        }\n\n        return output;\n      }\n\n    case 'max':\n      {\n        var currentMaxValue = max(input);\n        if (currentMaxValue === 0) return input.slice(0);\n        var factor = maxValue / currentMaxValue;\n\n        for (var _i = 0; _i < input.length; _i++) {\n          output[_i] = input[_i] * factor;\n        }\n\n        return output;\n      }\n\n    case 'sum':\n      {\n        var sumValue = sum(input);\n        if (sumValue === 0) return input.slice(0);\n\n        for (var _i2 = 0; _i2 < input.length; _i2++) {\n          output[_i2] = input[_i2] / sumValue;\n        }\n\n        return output;\n      }\n\n    default:\n      throw new Error(\"norm: unknown algorithm: \".concat(algorithm));\n  }\n}\n\nfunction absoluteSum(input) {\n  var sumValue = 0;\n\n  for (var i = 0; i < input.length; i++) {\n    sumValue += Math.abs(input[i]);\n  }\n\n  return sumValue;\n}\n\nexport default norm;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the minimum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction min(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var minValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\nexport default min;\n","import isArray from 'is-any-array';\nimport max from 'ml-array-max';\nimport min from 'ml-array-min';\n\n/**\n *\n * @param {Array} input\n * @param {object} [options={}]\n * @param {Array} [options.output=[]] specify the output array, can be the input array for in place modification\n */\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!isArray(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = min(input);\n  var currentMax = max(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\nexport default rescale;\n","import getZones from './getZones';\n\n/**\n * Filter an array x/y based on various criteria\n * x points are expected to be sorted\n *\n * @param {object} points\n * @param {object} [options={}]\n * @param {array} [options.from]\n * @param {array} [options.to]\n * @param {array} [options.exclusions=[]]\n * @return {{x: Array<number>, y: Array<number>}}\n */\n\nexport default function filterX(points, options = {}) {\n  const { x, y } = points;\n  const { from = x[0], to = x[x.length - 1], exclusions = [] } = options;\n\n  let zones = getZones(from, to, exclusions);\n\n\n  let currentZoneIndex = 0;\n  let newX = [];\n  let newY = [];\n  let position = 0;\n  while (position < x.length) {\n    if (\n      x[position] <= zones[currentZoneIndex].to &&\n      x[position] >= zones[currentZoneIndex].from\n    ) {\n      newX.push(x[position]);\n      newY.push(y[position]);\n    } else {\n      if (x[position] > zones[currentZoneIndex].to) {\n        currentZoneIndex++;\n        if (!zones[currentZoneIndex]) break;\n      }\n    }\n    position++;\n  }\n\n  return {\n    x: newX,\n    y: newY\n  };\n}\n","export default function getZones(from, to, exclusions = []) {\n  if (from > to) {\n    [from, to] = [to, from];\n  }\n\n  // in exclusions from and to have to be defined\n  exclusions = exclusions.filter(\n    (exclusion) => exclusion.from !== undefined && exclusion.to !== undefined\n  );\n\n  exclusions = JSON.parse(JSON.stringify(exclusions));\n  // we ensure that from before to\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from > exclusion.to) {\n      [exclusion.to, exclusion.from] = [exclusion.from, exclusion.to];\n    }\n  });\n\n  exclusions.sort((a, b) => a.from - b.from);\n\n  // we will rework the exclusions in order to remove overlap and outside range (from / to)\n  exclusions.forEach((exclusion) => {\n    if (exclusion.from < from) exclusion.from = from;\n    if (exclusion.to > to) exclusion.to = to;\n  });\n  for (let i = 0; i < exclusions.length - 1; i++) {\n    if (exclusions[i].to > exclusions[i + 1].from) {\n      exclusions[i].to = exclusions[i + 1].from;\n    }\n  }\n  exclusions = exclusions.filter((exclusion) => exclusion.from < exclusion.to);\n\n  if (!exclusions || exclusions.length === 0) {\n    return [{ from, to }];\n  }\n\n  let zones = [];\n  let currentFrom = from;\n  for (let exclusion of exclusions) {\n    if (currentFrom < exclusion.from) {\n      zones.push({\n        from: currentFrom,\n        to: exclusion.from\n      });\n    }\n\n    currentFrom = exclusion.to;\n  }\n  if (currentFrom < to) {\n    zones.push({\n      from: currentFrom,\n      to: to\n    });\n  }\n\n  return zones;\n}\n","import getNormalized from './util/getNormalized';\nimport sortX from 'ml-array-xy-sort-x';\n\nconst DEFAULT_FLAVOR = 'weightVersusTemperature';\n\n/**\n * Class allowing to store and manipulate a spectrum\n * @class Spectrum\n * @param {object} [data={}] - object containing a spectrum\n * @param {Array} [data.x=[]] - voltage\n * @param {Array} [data.y=[]] - intensity\n * @param {object} [options={}]\n */\nexport default class Spectrum {\n  constructor(options = {}) {\n    this.id = options.id || Math.random().toString(36).substring(2, 10);\n    this.flavors = {};\n  }\n\n  set(points, options = {}) {\n    const { flavor = DEFAULT_FLAVOR } = options;\n    this.flavors[flavor.toLowerCase()] = standardizeData(points, options);\n  }\n\n  get(flavor = DEFAULT_FLAVOR) {\n    flavor = flavor.toLowerCase();\n    if (!this.flavors[flavor]) {\n      return undefined;\n    }\n    return this.flavors[flavor];\n  }\n\n  getData(options = {}) {\n    const { flavor, normalization } = options;\n    let data = this.get(flavor);\n    if (!data) return undefined;\n    return getNormalized(data, normalization);\n  }\n\n  getXLabel(flavor) {\n    return this.get(flavor).xAxis;\n  }\n\n  getYLabel(flavor) {\n    return this.get(flavor).yAxis;\n  }\n}\n\nfunction standardizeData(points, options = {}) {\n  const { meta = {}, tmp = {}, xLabel = '', yLabel = '', title = '' } = options;\n  if (false) {\n    points = sortX(points);\n  } else {\n    let { x, y } = points;\n    if (x && x.length > 1 && x[0] > x[x.length - 1]) {\n      x = x.reverse();\n      y = y.reverse();\n    } else {\n      x = x || [];\n      y = y || [];\n    }\n    points = { x, y };\n  }\n\n  return {\n    x: points.x,\n    y: points.y,\n    xLabel,\n    yLabel,\n    title,\n    meta,\n    tmp,\n  };\n}\n","import equallySpaced from 'ml-array-xy-equally-spaced';\nimport Stat from 'ml-stat/array';\nimport normed from 'ml-array-normed';\nimport rescale from 'ml-array-rescale';\nimport filterX from 'ml-array-xy-filter-x';\n\n/**\n *\n * @private\n * @param {object} spectrum\n * @param {object} [options={}]\n * @param {number} [options.from=spectrum.x[0]]\n * @param {number} [options.to=spectrum.x[spectrum.x.length-1]]\n * @param {number} [options.numberOfPoints]\n * @param {Array} [options.filters=[]]\n * @param {Array} [options.exclusions=[]]\n */\nexport default function getNormalized(spectrum, options = {}) {\n  let {\n    from = spectrum.x[0],\n    to = spectrum.x[spectrum.x.length - 1],\n    numberOfPoints,\n    filters = [],\n    exclusions = [],\n  } = options;\n\n  let y = spectrum.y.slice(0);\n  console.log({ filters });\n  for (let filter of filters) {\n    switch (filter.name) {\n      case 'centerMean': {\n        let mean = Stat.mean(spectrum.y);\n        let meanFct = (y) => y - mean;\n        y = y.map(meanFct);\n        break;\n      }\n      case 'scaleSD': {\n        let std = Stat.standardDeviation(spectrum.y);\n        let stdFct = (y) => y / std;\n        y = y.map(stdFct);\n        break;\n      }\n      case 'normalize': {\n        y = normed(y);\n        break;\n      }\n      case 'rescale': {\n        y = rescale(y);\n        break;\n      }\n      case '':\n      case undefined:\n        break;\n      default:\n        throw new Error(`Unknown process kind: ${process.kind}`);\n    }\n  }\n  console.log({ from, to, spectrum, numberOfPoints });\n  if (!numberOfPoints) {\n    return filterX({ x: spectrum.x, y }, { from, to, exclusions });\n  }\n\n  return equallySpaced(\n    { x: spectrum.x, y },\n    { from, to, numberOfPoints, exclusions },\n  );\n}\n","export default function parsePerkinElmer(text) {\n  let lines = text.split(/[\\r\\n]+/);\n  let result = { meta: {}, data: { time: [], weight: [], temperature: [] } };\n  let section = '';\n  let inMethodSteps = false;\n  for (let line of lines) {\n    if (inMethodSteps) {\n      if (line.startsWith('1) TGA')) {\n        inMethodSteps = false;\n      } else {\n        if (!result.meta['Method Steps']) result.meta['Method Steps'] = '';\n        result.meta['Method Steps'] += `${line.replace(/\\t/g, '  ')}\\n`;\n      }\n    } else if (line.match(/^[a-zA-Z -]+$/)) {\n      section = trim(line);\n    } else if (line.match(/.*:.*/)) {\n      let position = line.indexOf(':');\n      let description = line.substring(0, position);\n      let value = trim(line.substring(position + 1));\n      result.meta[(section ? `${section}_` : '') + description] = value;\n    } else if (line.match(/^[0-9\\t .]+$/)) {\n      let fields = line.replace(/^\\t/, '').split('\\t');\n      result.data.time.push(Number(fields[0]));\n      result.data.weight.push(Number(fields[1]));\n      result.data.temperature.push(Number(fields[4]));\n    } else {\n      //  console.log('Problem: ', line);\n    }\n    if (line.startsWith('Method Steps:')) {\n      inMethodSteps = true;\n    }\n  }\n  return result;\n}\n\nfunction trim(string) {\n  return string.replace(/^[ \\t]*(.*?)[ \\t]*$/, '$1');\n}\n","const GC_MS_FIELDS = ['TIC', '.RIC', 'SCANNUMBER'];\n\nexport function complexChromatogram(result) {\n  let spectra = result.spectra;\n  let length = spectra.length;\n  let chromatogram = {\n    times: new Array(length),\n    series: {\n      ms: {\n        dimension: 2,\n        data: new Array(length),\n      },\n    },\n  };\n\n  let existingGCMSFields = [];\n  for (let i = 0; i < GC_MS_FIELDS.length; i++) {\n    let label = convertMSFieldToLabel(GC_MS_FIELDS[i]);\n    if (spectra[0][label]) {\n      existingGCMSFields.push(label);\n      chromatogram.series[label] = {\n        dimension: 1,\n        data: new Array(length),\n      };\n    }\n  }\n\n  for (let i = 0; i < length; i++) {\n    let spectrum = spectra[i];\n    chromatogram.times[i] = spectrum.pageValue;\n    for (let j = 0; j < existingGCMSFields.length; j++) {\n      chromatogram.series[existingGCMSFields[j]].data[i] = parseFloat(\n        spectrum[existingGCMSFields[j]],\n      );\n    }\n    if (spectrum.data) {\n      chromatogram.series.ms.data[i] = [spectrum.data.x, spectrum.data.y];\n    }\n  }\n  result.chromatogram = chromatogram;\n}\n\nexport function isMSField(canonicDataLabel) {\n  return GC_MS_FIELDS.indexOf(canonicDataLabel) !== -1;\n}\n\nexport function convertMSFieldToLabel(value) {\n  return value.toLowerCase().replace(/[^a-z0-9]/g, '');\n}\n","export default function convertToFloatArray(stringArray) {\n  let floatArray = [];\n  for (let i = 0; i < stringArray.length; i++) {\n    floatArray.push(parseFloat(stringArray[i]));\n  }\n  return floatArray;\n}\n","export default function fastParseXYData(spectrum, value) {\n  // TODO need to deal with result\n  //  console.log(value);\n  // we check if deltaX is defined otherwise we calculate it\n\n  let yFactor = spectrum.yFactor;\n  let deltaX = spectrum.deltaX;\n\n  spectrum.isXYdata = true;\n  // TODO to be improved using 2 array {x:[], y:[]}\n  let currentData = [];\n  spectrum.data = currentData;\n\n  let currentX = spectrum.firstX;\n  let currentY = spectrum.firstY;\n\n  // we skip the first line\n  //\n  let endLine = false;\n  let ascii;\n  let i = 0;\n  for (; i < value.length; i++) {\n    ascii = value.charCodeAt(i);\n    if (ascii === 13 || ascii === 10) {\n      endLine = true;\n    } else {\n      if (endLine) break;\n    }\n  }\n\n  // we proceed taking the i after the first line\n  let newLine = true;\n  let isDifference = false;\n  let isLastDifference = false;\n  let lastDifference = 0;\n  let isDuplicate = false;\n  let inComment = false;\n  let currentValue = 0; // can be a difference or a duplicate\n  let lastValue = 0; // must be the real last value\n  let isNegative = false;\n  let inValue = false;\n  let skipFirstValue = false;\n  let decimalPosition = 0;\n  for (; i <= value.length; i++) {\n    if (i === value.length) ascii = 13;\n    else ascii = value.charCodeAt(i);\n    if (inComment) {\n      // we should ignore the text if we are after $$\n      if (ascii === 13 || ascii === 10) {\n        newLine = true;\n        inComment = false;\n      }\n    } else {\n      // when is it a new value ?\n      // when it is not a digit, . or comma\n      // it is a number that is either new or we continue\n      if (ascii <= 57 && ascii >= 48) {\n        // a number\n        inValue = true;\n        if (decimalPosition > 0) {\n          currentValue += (ascii - 48) / Math.pow(10, decimalPosition++);\n        } else {\n          currentValue *= 10;\n          currentValue += ascii - 48;\n        }\n      } else if (ascii === 44 || ascii === 46) {\n        // a \",\" or \".\"\n        inValue = true;\n        decimalPosition++;\n      } else {\n        if (inValue) {\n          // need to process the previous value\n          if (newLine) {\n            newLine = false; // we don't check the X value\n            // console.log(\"NEW LINE\",isDifference, lastDifference);\n            // if new line and lastDifference, the first value is just a check !\n            // that we don't check ...\n            if (isLastDifference) skipFirstValue = true;\n          } else {\n            // need to deal with duplicate and differences\n            if (skipFirstValue) {\n              skipFirstValue = false;\n            } else {\n              if (isDifference) {\n                lastDifference = isNegative ? 0 - currentValue : currentValue;\n                isLastDifference = true;\n                isDifference = false;\n              } else if (!isDuplicate) {\n                lastValue = isNegative ? 0 - currentValue : currentValue;\n              }\n              let duplicate = isDuplicate ? currentValue - 1 : 1;\n              for (let j = 0; j < duplicate; j++) {\n                if (isLastDifference) {\n                  currentY += lastDifference;\n                } else {\n                  currentY = lastValue;\n                }\n                currentData.push(currentX);\n                currentData.push(currentY * yFactor);\n                currentX += deltaX;\n              }\n            }\n          }\n          isNegative = false;\n          currentValue = 0;\n          decimalPosition = 0;\n          inValue = false;\n          isDuplicate = false;\n        }\n\n        // positive SQZ digits @ A B C D E F G H I (ascii 64-73)\n        if (ascii < 74 && ascii > 63) {\n          inValue = true;\n          isLastDifference = false;\n          currentValue = ascii - 64;\n        } else if (ascii > 96 && ascii < 106) {\n          // negative SQZ digits a b c d e f g h i (ascii 97-105)\n          inValue = true;\n          isLastDifference = false;\n          currentValue = ascii - 96;\n          isNegative = true;\n        } else if (ascii === 115) {\n          // DUP digits S T U V W X Y Z s (ascii 83-90, 115)\n          inValue = true;\n          isDuplicate = true;\n          currentValue = 9;\n        } else if (ascii > 82 && ascii < 91) {\n          inValue = true;\n          isDuplicate = true;\n          currentValue = ascii - 82;\n        } else if (ascii > 73 && ascii < 83) {\n          // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n          inValue = true;\n          isDifference = true;\n          currentValue = ascii - 73;\n        } else if (ascii > 105 && ascii < 115) {\n          // negative DIF digits j k l m n o p q r (ascii 106-114)\n          inValue = true;\n          isDifference = true;\n          currentValue = ascii - 105;\n          isNegative = true;\n        } else if (ascii === 36 && value.charCodeAt(i + 1) === 36) {\n          // $ sign, we need to check the next one\n          inValue = true;\n          inComment = true;\n        } else if (ascii === 37) {\n          // positive DIF digits % J K L M N O P Q R (ascii 37, 74-82)\n          inValue = true;\n          isDifference = true;\n          currentValue = 0;\n          isNegative = false;\n        } else if (ascii === 45) {\n          // a \"-\"\n          // check if after there is a number, decimal or comma\n          let ascii2 = value.charCodeAt(i + 1);\n          if (\n            (ascii2 >= 48 && ascii2 <= 57) ||\n            ascii2 === 44 ||\n            ascii2 === 46\n          ) {\n            inValue = true;\n            if (!newLine) isLastDifference = false;\n            isNegative = true;\n          }\n        } else if (ascii === 13 || ascii === 10) {\n          newLine = true;\n          inComment = false;\n        }\n        // and now analyse the details ... space or tabulation\n        // if \"+\" we just don't care\n      }\n    }\n  }\n}\n","export default function parsePeakTable(spectrum, value, result) {\n  let removeCommentRegExp = /\\$\\$.*/;\n  let peakTableSplitRegExp = /[,\\t ]+/;\n\n  spectrum.isPeaktable = true;\n  let values;\n  let currentData = [];\n  spectrum.data = currentData;\n\n  // counts for around 20% of the time\n  let lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n  for (let i = 1; i < lines.length; i++) {\n    values = lines[i]\n      .trim()\n      .replace(removeCommentRegExp, '')\n      .split(peakTableSplitRegExp);\n    if (values.length % 2 === 0) {\n      for (let j = 0; j < values.length; j = j + 2) {\n        // takes around 40% of the time to add and parse the 2 values nearly exclusively because of parseFloat\n        currentData.push(parseFloat(values[j]) * spectrum.xFactor);\n        currentData.push(parseFloat(values[j + 1]) * spectrum.yFactor);\n      }\n    } else {\n      result.logs.push(`Format error: ${values}`);\n    }\n  }\n}\n","export default function parseXYA(spectrum, value) {\n  let removeSymbolRegExp = /(\\(+|\\)+|<+|>+|\\s+)/g;\n\n  spectrum.isXYAdata = true;\n  let values;\n  let currentData = [];\n  spectrum.data = currentData;\n\n  let lines = value.split(/,? *,?[;\\r\\n]+ */);\n\n  for (let i = 1; i < lines.length; i++) {\n    values = lines[i].trim().replace(removeSymbolRegExp, '').split(',');\n    currentData.push(parseFloat(values[0]));\n    currentData.push(parseFloat(values[1]));\n  }\n}\n","(function(){function a(d){for(var e=0,f=d.length-1,g=void 0,h=void 0,i=void 0,j=c(e,f);!0;){if(f<=e)return d[j];if(f==e+1)return d[e]>d[f]&&b(d,e,f),d[j];for(g=c(e,f),d[g]>d[f]&&b(d,g,f),d[e]>d[f]&&b(d,e,f),d[g]>d[e]&&b(d,g,e),b(d,g,e+1),h=e+1,i=f;!0;){do h++;while(d[e]>d[h]);do i--;while(d[i]>d[e]);if(i<h)break;b(d,h,i)}b(d,e,i),i<=j&&(e=h),i>=j&&(f=i-1)}}var b=function b(d,e,f){var _ref;return _ref=[d[f],d[e]],d[e]=_ref[0],d[f]=_ref[1],_ref},c=function c(d,e){return~~((d+e)/2)};'undefined'!=typeof module&&module.exports?module.exports=a:window.median=a})();\n","import isArray from 'is-any-array';\nimport quickSelectMedian from 'median-quickselect';\n\n/**\n * Computes the median of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction median(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  return quickSelectMedian(input.slice());\n}\n\nexport default median;\n","import convertTo3DZ from './convertTo3DZ';\nimport generateContourLines from './generateContourLines';\n\nexport default function add2D(result, options) {\n  let zData = convertTo3DZ(result.spectra);\n  if (!options.noContour) {\n    result.contourLines = generateContourLines(zData, options);\n    delete zData.z;\n  }\n  result.minMax = zData;\n}\n","import getMedian from 'ml-array-median';\n\nexport default function convertTo3DZ(spectra) {\n  let minZ = spectra[0].data[0];\n  let maxZ = minZ;\n  let ySize = spectra.length;\n  let xSize = spectra[0].data.length / 2;\n  let z = new Array(ySize);\n  for (let i = 0; i < ySize; i++) {\n    z[i] = new Array(xSize);\n    let xVector = spectra[i].data;\n    for (let j = 0; j < xSize; j++) {\n      let value = xVector[j * 2 + 1];\n      z[i][j] = value;\n      if (value < minZ) minZ = value;\n      if (value > maxZ) maxZ = value;\n    }\n  }\n\n  const firstX = spectra[0].data[0];\n  const lastX = spectra[0].data[spectra[0].data.length - 2]; // has to be -2 because it is a 1D array [x,y,x,y,...]\n  const firstY = spectra[0].pageValue;\n  const lastY = spectra[ySize - 1].pageValue;\n\n  // Because the min / max value are the only information about the matrix if we invert\n  // min and max we need to invert the array\n  if (firstX > lastX) {\n    for (let spectrum of z) {\n      spectrum.reverse();\n    }\n  }\n  if (firstY > lastY) {\n    z.reverse();\n  }\n\n  return {\n    z: z,\n    minX: Math.min(firstX, lastX),\n    maxX: Math.max(firstX, lastX),\n    minY: Math.min(firstY, lastY),\n    maxY: Math.max(firstY, lastY),\n    minZ: minZ,\n    maxZ: maxZ,\n    noise: getMedian(z[0].map(Math.abs)),\n  };\n}\n","export default function generateContourLines(zData, options) {\n  let noise = zData.noise;\n  let z = zData.z;\n  let povarHeight0, povarHeight1, povarHeight2, povarHeight3;\n  let isOver0, isOver1, isOver2, isOver3;\n  let nbSubSpectra = z.length;\n  let nbPovars = z[0].length;\n  let pAx, pAy, pBx, pBy;\n\n  let x0 = zData.minX;\n  let xN = zData.maxX;\n  let dx = (xN - x0) / (nbPovars - 1);\n  let y0 = zData.minY;\n  let yN = zData.maxY;\n  let dy = (yN - y0) / (nbSubSpectra - 1);\n  let minZ = zData.minZ;\n  let maxZ = zData.maxZ;\n\n  // System.out.prvarln('y0 '+y0+' yN '+yN);\n  // -------------------------\n  // Povars attribution\n  //\n  // 0----1\n  // |  / |\n  // | /  |\n  // 2----3\n  //\n  // ---------------------d------\n\n  let iter = options.nbContourLevels * 2;\n  let contourLevels = new Array(iter);\n  let lineZValue;\n  for (let level = 0; level < iter; level++) {\n    // multiply by 2 for positif and negatif\n    let contourLevel = {};\n    contourLevels[level] = contourLevel;\n    let side = level % 2;\n    let factor =\n      (maxZ - options.noiseMultiplier * noise) *\n      Math.exp((level >> 1) - options.nbContourLevels);\n    if (side === 0) {\n      lineZValue = factor + options.noiseMultiplier * noise;\n    } else {\n      lineZValue = 0 - factor - options.noiseMultiplier * noise;\n    }\n    let lines = [];\n    contourLevel.zValue = lineZValue;\n    contourLevel.lines = lines;\n\n    if (lineZValue <= minZ || lineZValue >= maxZ) continue;\n\n    for (let iSubSpectra = 0; iSubSpectra < nbSubSpectra - 1; iSubSpectra++) {\n      let subSpectra = z[iSubSpectra];\n      let subSpectraAfter = z[iSubSpectra + 1];\n      for (let povar = 0; povar < nbPovars - 1; povar++) {\n        povarHeight0 = subSpectra[povar];\n        povarHeight1 = subSpectra[povar + 1];\n        povarHeight2 = subSpectraAfter[povar];\n        povarHeight3 = subSpectraAfter[povar + 1];\n\n        isOver0 = povarHeight0 > lineZValue;\n        isOver1 = povarHeight1 > lineZValue;\n        isOver2 = povarHeight2 > lineZValue;\n        isOver3 = povarHeight3 > lineZValue;\n\n        // Example povar0 is over the plane and povar1 and\n        // povar2 are below, we find the varersections and add\n        // the segment\n        if (isOver0 !== isOver1 && isOver0 !== isOver2) {\n          pAx =\n            povar + (lineZValue - povarHeight0) / (povarHeight1 - povarHeight0);\n          pAy = iSubSpectra;\n          pBx = povar;\n          pBy =\n            iSubSpectra +\n            (lineZValue - povarHeight0) / (povarHeight2 - povarHeight0);\n          lines.push(pAx * dx + x0);\n          lines.push(pAy * dy + y0);\n          lines.push(pBx * dx + x0);\n          lines.push(pBy * dy + y0);\n        }\n        // remove push does not help !!!!\n        if (isOver3 !== isOver1 && isOver3 !== isOver2) {\n          pAx = povar + 1;\n          pAy =\n            iSubSpectra +\n            1 -\n            (lineZValue - povarHeight3) / (povarHeight1 - povarHeight3);\n          pBx =\n            povar +\n            1 -\n            (lineZValue - povarHeight3) / (povarHeight2 - povarHeight3);\n          pBy = iSubSpectra + 1;\n          lines.push(pAx * dx + x0);\n          lines.push(pAy * dy + y0);\n          lines.push(pBx * dx + x0);\n          lines.push(pBy * dy + y0);\n        }\n        // test around the diagonal\n        if (isOver1 !== isOver2) {\n          pAx =\n            (povar +\n              1 -\n              (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) *\n              dx +\n            x0;\n          pAy =\n            (iSubSpectra +\n              (lineZValue - povarHeight1) / (povarHeight2 - povarHeight1)) *\n              dy +\n            y0;\n          if (isOver1 !== isOver0) {\n            pBx =\n              povar +\n              1 -\n              (lineZValue - povarHeight1) / (povarHeight0 - povarHeight1);\n            pBy = iSubSpectra;\n            lines.push(pAx);\n            lines.push(pAy);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n          if (isOver2 !== isOver0) {\n            pBx = povar;\n            pBy =\n              iSubSpectra +\n              1 -\n              (lineZValue - povarHeight2) / (povarHeight0 - povarHeight2);\n            lines.push(pAx);\n            lines.push(pAy);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n          if (isOver1 !== isOver3) {\n            pBx = povar + 1;\n            pBy =\n              iSubSpectra +\n              (lineZValue - povarHeight1) / (povarHeight3 - povarHeight1);\n            lines.push(pAx);\n            lines.push(pAy);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n          if (isOver2 !== isOver3) {\n            pBx =\n              povar +\n              (lineZValue - povarHeight2) / (povarHeight3 - povarHeight2);\n            pBy = iSubSpectra + 1;\n            lines.push(pAx);\n            lines.push(pAy);\n            lines.push(pBx * dx + x0);\n            lines.push(pBy * dy + y0);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    minX: zData.minX,\n    maxX: zData.maxX,\n    minY: zData.minY,\n    maxY: zData.maxY,\n    segments: contourLevels,\n  };\n}\n","export default function profiling(result, action, options) {\n  if (result.profiling) {\n    result.profiling.push({\n      action,\n      time: Date.now() - options.start,\n    });\n  }\n}\n","export default function simpleChromatogram(result) {\n  let data = result.spectra[0].data;\n  result.chromatogram = {\n    times: data.x.slice(),\n    series: {\n      intensity: {\n        dimension: 1,\n        data: data.y.slice(),\n      },\n    },\n  };\n}\n","export default function prepareSpectrum(spectrum) {\n  if (!spectrum.xFactor) spectrum.xFactor = 1;\n  if (!spectrum.yFactor) spectrum.yFactor = 1;\n  if (spectrum.observeFrequency) {\n    if (spectrum.xUnit && spectrum.xUnit.toUpperCase() === 'HZ') {\n      spectrum.xUnit = 'PPM';\n      spectrum.xFactor = spectrum.xFactor / spectrum.observeFrequency;\n      spectrum.firstX = spectrum.firstX / spectrum.observeFrequency;\n      spectrum.lastX = spectrum.lastX / spectrum.observeFrequency;\n      spectrum.deltaX = spectrum.deltaX / spectrum.observeFrequency;\n    }\n  }\n  if (spectrum.shiftOffsetVal) {\n    let shift = spectrum.firstX - spectrum.shiftOffsetVal;\n    spectrum.firstX = spectrum.firstX - shift;\n    spectrum.lastX = spectrum.lastX - shift;\n  }\n}\n","import { isMSField, convertMSFieldToLabel } from './complexChromatogram';\nimport convertToFloatArray from './convertToFloatArray';\nimport fastParseXYData from './parse/fastParseXYData';\nimport parsePeakTable from './parse/parsePeakTable';\nimport parseXYA from './parse/parseXYA';\nimport postProcessing from './postProcessing';\nimport prepareSpectrum from './prepareSpectrum';\nimport profiling from './profiling';\n\n// the following RegExp can only be used for XYdata, some peakTables have values with a \"E-5\" ...\nconst ntuplesSeparator = /[, \\t]+/;\n\nclass Spectrum {}\n\nconst defaultOptions = {\n  keepRecordsRegExp: /^$/,\n  canonicDataLabels: true,\n  dynamicTyping: false,\n  xy: true,\n  withoutXY: false,\n  chromatogram: false,\n  keepSpectra: false,\n  noContour: false,\n  nbContourLevels: 7,\n  noiseMultiplier: 5,\n  profiling: false,\n};\n\nexport default function convert(jcamp, options) {\n  options = Object.assign({}, defaultOptions, options);\n  options.wantXY = !options.withoutXY;\n  options.start = Date.now();\n\n  let entriesFlat = [];\n\n  let result = {\n    profiling: options.profiling ? [] : false,\n    logs: [],\n    entries: [],\n  };\n\n  let tmpResult = { children: [] };\n  let currentEntry = tmpResult;\n  let parentsStack = [];\n\n  let spectrum = new Spectrum();\n\n  if (typeof jcamp !== 'string') {\n    throw new TypeError('the JCAMP should be a string');\n  }\n\n  profiling(result, 'Before split to LDRS', options);\n\n  let ldrs = jcamp.replace(/[\\r\\n]+##/g, '\\n##').split('\\n##');\n\n  profiling(result, 'Split to LDRS', options);\n\n  if (ldrs[0]) ldrs[0] = ldrs[0].replace(/^[\\r\\n ]*##/, '');\n\n  for (let ldr of ldrs) {\n    // This is a new LDR\n    let position = ldr.indexOf('=');\n    let dataLabel = position > 0 ? ldr.substring(0, position) : ldr;\n    let dataValue = position > 0 ? ldr.substring(position + 1).trim() : '';\n\n    let canonicDataLabel = dataLabel.replace(/[_ -]/g, '').toUpperCase();\n\n    if (canonicDataLabel === 'DATATABLE') {\n      let endLine = dataValue.indexOf('\\n');\n      if (endLine === -1) endLine = dataValue.indexOf('\\r');\n      if (endLine > 0) {\n        let xIndex = -1;\n        let yIndex = -1;\n        // ##DATA TABLE= (X++(I..I)), XYDATA\n        // We need to find the variables\n\n        let infos = dataValue.substring(0, endLine).split(/[ ,;\\t]+/);\n        if (infos[0].indexOf('++') > 0) {\n          let firstVariable = infos[0].replace(\n            /.*\\(([a-zA-Z0-9]+)\\+\\+.*/,\n            '$1',\n          );\n          let secondVariable = infos[0].replace(/.*\\.\\.([a-zA-Z0-9]+).*/, '$1');\n          xIndex = currentEntry.ntuples.symbol.indexOf(firstVariable);\n          yIndex = currentEntry.ntuples.symbol.indexOf(secondVariable);\n        }\n\n        if (xIndex === -1) xIndex = 0;\n        if (yIndex === -1) yIndex = 0;\n\n        if (currentEntry.ntuples.first) {\n          if (currentEntry.ntuples.first.length > xIndex) {\n            spectrum.firstX = currentEntry.ntuples.first[xIndex];\n          }\n          if (currentEntry.ntuples.first.length > yIndex) {\n            spectrum.firstY = currentEntry.ntuples.first[yIndex];\n          }\n        }\n        if (currentEntry.ntuples.last) {\n          if (currentEntry.ntuples.last.length > xIndex) {\n            spectrum.lastX = currentEntry.ntuples.last[xIndex];\n          }\n          if (currentEntry.ntuples.last.length > yIndex) {\n            spectrum.lastY = currentEntry.ntuples.last[yIndex];\n          }\n        }\n        if (\n          currentEntry.ntuples.vardim &&\n          currentEntry.ntuples.vardim.length > xIndex\n        ) {\n          spectrum.nbPoints = currentEntry.ntuples.vardim[xIndex];\n        }\n        if (currentEntry.ntuples.factor) {\n          if (currentEntry.ntuples.factor.length > xIndex) {\n            spectrum.xFactor = currentEntry.ntuples.factor[xIndex];\n          }\n          if (currentEntry.ntuples.factor.length > yIndex) {\n            spectrum.yFactor = currentEntry.ntuples.factor[yIndex];\n          }\n        }\n        if (currentEntry.ntuples.units) {\n          if (currentEntry.ntuples.units.length > xIndex) {\n            spectrum.xUnit = currentEntry.ntuples.units[xIndex];\n          }\n          if (currentEntry.ntuples.units.length > yIndex) {\n            spectrum.yUnit = currentEntry.ntuples.units[yIndex];\n          }\n        }\n        spectrum.datatable = infos[0];\n        if (infos[1] && infos[1].indexOf('PEAKS') > -1) {\n          canonicDataLabel = 'PEAKTABLE';\n        } else if (\n          infos[1] &&\n          (infos[1].indexOf('XYDATA') || infos[0].indexOf('++') > 0)\n        ) {\n          canonicDataLabel = 'XYDATA';\n          spectrum.deltaX =\n            (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n        }\n      }\n    }\n\n    if (canonicDataLabel === 'XYDATA') {\n      if (options.wantXY) {\n        prepareSpectrum(spectrum);\n        // well apparently we should still consider it is a PEAK TABLE if there are no '++' after\n        if (dataValue.match(/.*\\+\\+.*/)) {\n          // ex: (X++(Y..Y))\n          if (!spectrum.deltaX) {\n            spectrum.deltaX =\n              (spectrum.lastX - spectrum.firstX) / (spectrum.nbPoints - 1);\n          }\n          fastParseXYData(spectrum, dataValue, result);\n        } else {\n          parsePeakTable(spectrum, dataValue, result);\n        }\n        currentEntry.spectra.push(spectrum);\n        spectrum = new Spectrum();\n      }\n      continue;\n    } else if (canonicDataLabel === 'PEAKTABLE') {\n      if (options.wantXY) {\n        prepareSpectrum(spectrum);\n        parsePeakTable(spectrum, dataValue, result);\n        currentEntry.spectra.push(spectrum);\n        spectrum = new Spectrum();\n      }\n      continue;\n    }\n    if (canonicDataLabel === 'PEAKASSIGNMENTS') {\n      if (options.wantXY) {\n        if (dataValue.match(/.*(XYA).*/)) {\n          // ex: (XYA)\n          parseXYA(spectrum, dataValue);\n        }\n        currentEntry.spectra.push(spectrum);\n        spectrum = new Spectrum();\n      }\n      continue;\n    }\n\n    if (canonicDataLabel === 'TITLE') {\n      let parentEntry = currentEntry;\n      if (!parentEntry.children) {\n        parentEntry.children = [];\n      }\n      currentEntry = {\n        spectra: [],\n        ntuples: {},\n        info: {},\n      };\n      parentEntry.children.push(currentEntry);\n      parentsStack.push(parentEntry);\n      entriesFlat.push(currentEntry);\n      currentEntry.title = dataValue;\n    } else if (canonicDataLabel === 'DATATYPE') {\n      currentEntry.dataType = dataValue;\n      if (dataValue.indexOf('nD') > -1) {\n        currentEntry.twoD = true;\n      }\n    } else if (canonicDataLabel === 'NTUPLES') {\n      if (dataValue.indexOf('nD') > -1) {\n        currentEntry.twoD = true;\n      }\n    } else if (canonicDataLabel === 'DATACLASS') {\n      currentEntry.dataClass = dataValue;\n    } else if (canonicDataLabel === 'XUNITS') {\n      spectrum.xUnit = dataValue;\n    } else if (canonicDataLabel === 'YUNITS') {\n      spectrum.yUnit = dataValue;\n    } else if (canonicDataLabel === 'FIRSTX') {\n      spectrum.firstX = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'LASTX') {\n      spectrum.lastX = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'FIRSTY') {\n      spectrum.firstY = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'LASTY') {\n      spectrum.lastY = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'NPOINTS') {\n      spectrum.nbPoints = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'XFACTOR') {\n      spectrum.xFactor = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'YFACTOR') {\n      spectrum.yFactor = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'MAXX') {\n      spectrum.maxX = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'MINX') {\n      spectrum.minX = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'MAXY') {\n      spectrum.maxY = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'MINY') {\n      spectrum.minY = parseFloat(dataValue);\n    } else if (canonicDataLabel === 'DELTAX') {\n      spectrum.deltaX = parseFloat(dataValue);\n    } else if (\n      canonicDataLabel === '.OBSERVEFREQUENCY' ||\n      canonicDataLabel === '$SFO1'\n    ) {\n      if (!spectrum.observeFrequency) {\n        spectrum.observeFrequency = parseFloat(dataValue);\n      }\n    } else if (canonicDataLabel === '.OBSERVENUCLEUS') {\n      if (!spectrum.xType) {\n        currentEntry.xType = dataValue.replace(/[^a-zA-Z0-9]/g, '');\n      }\n    } else if (canonicDataLabel === '$SFO2') {\n      if (!currentEntry.indirectFrequency) {\n        currentEntry.indirectFrequency = parseFloat(dataValue);\n      }\n    } else if (canonicDataLabel === '$OFFSET') {\n      // OFFSET for Bruker spectra\n      currentEntry.shiftOffsetNum = 0;\n      if (!spectrum.shiftOffsetVal) {\n        spectrum.shiftOffsetVal = parseFloat(dataValue);\n      }\n    } else if (canonicDataLabel === '$REFERENCEPOINT') {\n      // OFFSET for Varian spectra\n      // if we activate this part it does not work for ACD specmanager\n      //         } else if (canonicDataLabel=='.SHIFTREFERENCE') {   // OFFSET FOR Bruker Spectra\n      //                 var parts = dataValue.split(/ *, */);\n      //                 currentEntry.shiftOffsetNum = parseInt(parts[2].trim());\n      //                 spectrum.shiftOffsetVal = parseFloat(parts[3].trim());\n    } else if (canonicDataLabel === 'VARNAME') {\n      currentEntry.ntuples.varname = dataValue.split(ntuplesSeparator);\n    } else if (canonicDataLabel === 'SYMBOL') {\n      currentEntry.ntuples.symbol = dataValue.split(ntuplesSeparator);\n    } else if (canonicDataLabel === 'VARTYPE') {\n      currentEntry.ntuples.vartype = dataValue.split(ntuplesSeparator);\n    } else if (canonicDataLabel === 'VARFORM') {\n      currentEntry.ntuples.varform = dataValue.split(ntuplesSeparator);\n    } else if (canonicDataLabel === 'VARDIM') {\n      currentEntry.ntuples.vardim = convertToFloatArray(\n        dataValue.split(ntuplesSeparator),\n      );\n    } else if (canonicDataLabel === 'UNITS') {\n      currentEntry.ntuples.units = dataValue.split(ntuplesSeparator);\n    } else if (canonicDataLabel === 'FACTOR') {\n      currentEntry.ntuples.factor = convertToFloatArray(\n        dataValue.split(ntuplesSeparator),\n      );\n    } else if (canonicDataLabel === 'FIRST') {\n      currentEntry.ntuples.first = convertToFloatArray(\n        dataValue.split(ntuplesSeparator),\n      );\n    } else if (canonicDataLabel === 'LAST') {\n      currentEntry.ntuples.last = convertToFloatArray(\n        dataValue.split(ntuplesSeparator),\n      );\n    } else if (canonicDataLabel === 'MIN') {\n      currentEntry.ntuples.min = convertToFloatArray(\n        dataValue.split(ntuplesSeparator),\n      );\n    } else if (canonicDataLabel === 'MAX') {\n      currentEntry.ntuples.max = convertToFloatArray(\n        dataValue.split(ntuplesSeparator),\n      );\n    } else if (canonicDataLabel === '.NUCLEUS') {\n      if (currentEntry.twoD) {\n        currentEntry.yType = dataValue.split(ntuplesSeparator)[0];\n      }\n    } else if (canonicDataLabel === 'PAGE') {\n      spectrum.page = dataValue.trim();\n      spectrum.pageValue = parseFloat(dataValue.replace(/^.*=/, ''));\n      spectrum.pageSymbol = spectrum.page.replace(/[=].*/, '');\n      let pageSymbolIndex = currentEntry.ntuples.symbol.indexOf(\n        spectrum.pageSymbol,\n      );\n      let unit = '';\n      if (\n        currentEntry.ntuples.units &&\n        currentEntry.ntuples.units[pageSymbolIndex]\n      ) {\n        unit = currentEntry.ntuples.units[pageSymbolIndex];\n      }\n      if (currentEntry.indirectFrequency && unit !== 'PPM') {\n        spectrum.pageValue /= currentEntry.indirectFrequency;\n      }\n    } else if (canonicDataLabel === 'RETENTIONTIME') {\n      spectrum.pageValue = parseFloat(dataValue);\n    } else if (isMSField(canonicDataLabel)) {\n      spectrum[convertMSFieldToLabel(canonicDataLabel)] = dataValue;\n    } else if (canonicDataLabel === 'SAMPLEDESCRIPTION') {\n      spectrum.sampleDescription = dataValue;\n    } else if (canonicDataLabel === 'END') {\n      currentEntry = parentsStack.pop();\n    }\n\n    if (\n      currentEntry &&\n      currentEntry.info &&\n      canonicDataLabel.match(options.keepRecordsRegExp)\n    ) {\n      let label = options.canonicDataLabels ? canonicDataLabel : dataLabel;\n      let value = dataValue.trim();\n      if (options.dynamicTyping && !isNaN(value)) {\n        value = Number(value);\n      }\n      if (currentEntry.info[label]) {\n        if (!Array.isArray(currentEntry.info[label])) {\n          currentEntry.info[label] = [currentEntry.info[label]];\n        }\n        currentEntry.info[label].push(value);\n      } else {\n        currentEntry.info[label] = value;\n      }\n    }\n  }\n\n  profiling(result, 'Finished parsing', options);\n\n  postProcessing(entriesFlat, result, options);\n\n  profiling(result, 'Total time', options);\n\n  /*\n  if (result.children && result.children.length>0) {\n    result = { ...result, ...result.children[0] };\n  }\n  */\n  result.entries = tmpResult.children;\n  result.flatten = entriesFlat;\n\n  return result;\n}\n","import add2D from './2d/add2D';\nimport { complexChromatogram } from './complexChromatogram';\nimport profiling from './profiling';\nimport simpleChromatogram from './simpleChromatogram';\n\nexport default function postProcessing(entriesFlat, result, options) {\n  for (let entry of entriesFlat) {\n    if (Object.keys(entry.ntuples).length > 0) {\n      let newNtuples = [];\n      let keys = Object.keys(entry.ntuples);\n      for (let i = 0; i < keys.length; i++) {\n        let key = keys[i];\n        let values = entry.ntuples[key];\n        for (let j = 0; j < values.length; j++) {\n          if (!newNtuples[j]) newNtuples[j] = {};\n          newNtuples[j][key] = values[j];\n        }\n      }\n      entry.ntuples = newNtuples;\n    }\n\n    if (entry.twoD && options.wantXY) {\n      add2D(entry, options);\n\n      profiling(result, 'Finished countour plot calculation', options);\n\n      if (!options.keepSpectra) {\n        delete entry.spectra;\n      }\n    }\n\n    if (options.chromatogram) {\n      options.xy = true;\n    }\n\n    if (options.xy && options.wantXY) {\n      // the spectraData should not be a oneD array but an object with x and y\n      if (entry.spectra && entry.spectra.length > 0) {\n        for (let spectrum of entry.spectra) {\n          if (spectrum.data) {\n            let data = spectrum.data;\n            let newData = {\n              x: new Array(data.length / 2),\n              y: new Array(data.length / 2),\n            };\n            for (let k = 0; k < data.length; k = k + 2) {\n              newData.x[k / 2] = data[k];\n              newData.y[k / 2] = data[k + 1];\n            }\n            spectrum.data = newData;\n          }\n        }\n      }\n    }\n\n    // maybe it is a GC (HPLC) / MS. In this case we add a new format\n    if (options.chromatogram) {\n      if (entry.spectra.length > 1) {\n        complexChromatogram(entry);\n      } else {\n        simpleChromatogram(entry);\n      }\n      profiling(result, 'Finished chromatogram calculation', options);\n    }\n  }\n}\n","export function fromXxyyArray(data) {\n  return { x: data[0], y: data[1] };\n}\n\nexport function fromXyxyArray(data) {\n  var x = [];\n  var y = [];\n  for (const point of data) {\n    x.push(point[0]);\n    y.push(point[1]);\n  }\n  return { x, y };\n}\n\nexport function fromXyxyObject(data) {\n  var x = [];\n  var y = [];\n  for (const point of data) {\n    x.push(point.x);\n    y.push(point.y);\n  }\n  return { x, y };\n}\n\nexport function fromGeneral(data) {\n  if (Array.isArray(data)) {\n    if (data.length === 0) return { x: [], y: [] };\n    if (Array.isArray(data[0])) {\n      if (data.length === 2) {\n        return fromXxyyArray(data);\n      } else {\n        return fromXyxyArray(data);\n      }\n    } else {\n      return fromXyxyObject(data);\n    }\n  } else {\n    if (Array.isArray(data.x) && Array.isArray(data.x)) {\n      return data;\n    } else {\n      throw new TypeError('unknown data format');\n    }\n  }\n}\n","import { fromGeneral, fromXxyyArray, fromXyxyArray, fromXyxyObject } from './from';\nimport { toXxyyArray, toXyxyArray, toXyxyObject } from './to';\n\n/**\n * Convert between different xy formats\n * @param {*} data - input set of points to parse\n * @param {object} [options] - input and output options\n * @param {string} [options.inputFormat] - input format, if not in list infers the kind\n * @param {string} [options.outputFormat = 'xxyyObject'] - output format\n * @return {*} - output set of points\n */\nexport default function xyConvert(data, options = {}) {\n  const { inputFormat, outputFormat = 'xxyyObject' } = options;\n\n  if (inputFormat === outputFormat) return data;\n\n  let middleData;\n  switch (inputFormat) {\n    case 'xxyyArray':\n      middleData = fromXxyyArray(data);\n      break;\n\n    case 'xyxyArray':\n      middleData = fromXyxyArray(data);\n      break;\n\n    case 'xxyyObject':\n      // this is the base case\n      middleData = data;\n      break;\n\n    case 'xyxyObject':\n      middleData = fromXyxyObject(data);\n      break;\n\n    default:\n      middleData = fromGeneral(data);\n      break;\n  }\n\n  switch (outputFormat) {\n    case 'xxyyArray':\n      return toXxyyArray(middleData);\n\n    case 'xyxyArray':\n      return toXyxyArray(middleData);\n\n    case 'xxyyObject':\n      return middleData;\n\n    case 'xyxyObject':\n      return toXyxyObject(middleData);\n\n    default:\n      throw new TypeError(`unknown output format ${outputFormat}`);\n  }\n}\n","export function toXxyyArray({ x, y }) {\n  return [x, y];\n}\n\nexport function toXyxyArray({ x, y }) {\n  var ans = [];\n  for (var index = 0; index < x.length; index++) {\n    ans.push([x[index], y[index]]);\n  }\n  return ans;\n}\n\nexport function toXyxyObject({ x, y }) {\n  var ans = [];\n  for (var index = 0; index < x.length; index++) {\n    ans.push({ x: x[index], y: y[index] });\n  }\n  return ans;\n}\n","import { parseXY } from 'xy-parser';\nimport xyConvert from 'ml-xy-convert';\n\nimport creator from './creator';\n\n/**\n * Convert strings into JCAMP and add extra information\n * @param {string} data - values to add to the file, usually a csv or tsv values\n * @param {object} [options={}]\n * @param {string} [options.meta] - metadata of the file\n * @param {string} [options.meta.title = ''] - title of the file\n * @param {string} [options.meta.owner = ''] - owner of the file\n * @param {string} [options.meta.origin = ''] - origin of the file\n * @param {string} [options.meta.type = ''] - type of data\n * @param {string} [options.meta.xUnit = ''] - units for the x axis\n * @param {string} [options.meta.yUnit = ''] - units for the y axis\n * @param {object} [options.meta.info = {}] - comments to add to the file\n * @param {object} [options.parser = {}] - 'xy-parser' options. arrayType = 'xyxy' is enforced\n * @return {string} JCAMP of the input\n */\nexport function fromText(data, options = {}) {\n  const { meta = {}, parserOptions = {} } = options;\n\n  parserOptions.keepInfo = true;\n  let parsed = parseXY(data, parserOptions);\n\n  if (!meta.info) meta.info = {};\n  meta.info.header = parsed.info.map((i) => i.value).join('\\n');\n  let jcamp = creator(parsed.data, meta);\n  return jcamp;\n}\n\n/**\n * Parse from any supported format in ml-xy-convert\n * @param {*} data - object or array with a set of points\n * @param {object} [meta] - metadata object\n * @return {string} JCAMP of the input\n */\nexport function fromJSON(data, meta = {}) {\n  const parsed = xyConvert(data, { outputFormat: 'xxyyObject' });\n  return creator(parsed, meta);\n}\n","/**\n * Parse from a xyxy data array\n * @param {Array<Array<number>>} data\n * @param {object} [meta] - same metadata object format that the fromText\n * @return {string} JCAMP of the input\n */\nexport default function creator(data, meta = {}) {\n  const {\n    title = '',\n    owner = '',\n    origin = '',\n    type = '',\n    xUnit = '',\n    yUnit = '',\n    info = {},\n  } = meta;\n  let firstX = Number.POSITIVE_INFINITY;\n  let lastX = Number.NEGATIVE_INFINITY;\n  let firstY = Number.POSITIVE_INFINITY;\n  let lastY = Number.NEGATIVE_INFINITY;\n  let points = [];\n\n  for (let i = 0; i < data.x.length; i++) {\n    let x = data.x[i];\n    let y = data.y[i];\n    if (firstX > x) {\n      firstX = x;\n    }\n    if (lastX < x) {\n      lastX = x;\n    }\n    if (firstY > y) {\n      firstY = y;\n    }\n    if (lastY < y) {\n      lastY = y;\n    }\n    points.push(`${x} ${y}`);\n  }\n\n  let header = `##TITLE=${title}\n##JCAMP-DX=4.24\n##DATA TYPE=${type}\n##ORIGIN=${origin}\n##OWNER=${owner}\n##XUNITS=${xUnit}\n##YUNITS=${yUnit}\n##FIRSTX=${firstX}\n##LASTX=${lastX}\n##FIRSTY=${firstY}\n##LASTY=${lastY}\\n`;\n\n  for (const key of Object.keys(info)) {\n    header += `##$${key}=${info[key]}\\n`;\n  }\n\n  // we leave the header and utf8 fonts ${header.replace(/[^\\t\\r\\n\\x20-\\x7F]/g, '')\n\n  return `${header}##NPOINTS=${points.length}\n##PEAK TABLE=(XY..XY)\n${points.join('\\n')}\n##END`;\n}\n","import { fromJSON } from 'convert-to-jcamp';\n\nexport default function toJcamp(spectrum) {\n  let jcamps = [];\n  let weightVersusTemperature = spectrum.get('weightVersusTemperature');\n  if (weightVersusTemperature) {\n    jcamps.push(getJcamp(weightVersusTemperature));\n  }\n  let weightVersusTime = spectrum.get('weightVersusTime');\n  if (weightVersusTime) {\n    jcamps.push(getJcamp(weightVersusTime));\n  }\n\n  return jcamps.join('\\n');\n}\n\nfunction getJcamp(spectrum) {\n  let options = {\n    xUnit: spectrum.xLabel,\n    yUnit: spectrum.yLabel,\n    title: spectrum.title,\n    type: 'TGA',\n    info: spectrum.meta,\n  };\n  return fromJSON({ x: spectrum.x, y: spectrum.y }, options);\n}\n","export default function addStyle(data, spectrum, options = {}) {\n  const { color = 'darkgrey' } = options;\n  data.styles = {\n    unselected: {\n      lineColor: color,\n      lineWidth: 1,\n      lineStyle: 1,\n    },\n    selected: {\n      lineColor: color,\n      lineWidth: 3,\n      lineStyle: 1,\n    },\n  };\n  data.label = spectrum.id;\n}\n","export default class Spectra {\n  constructor() {\n    this.data = [];\n  }\n\n  addSpectrum(spectrum) {\n    let index = this.getSpectrumIndex(spectrum.id);\n    if (index === undefined) {\n      this.data.push(spectrum);\n    } else {\n      this.data[index] = spectrum;\n    }\n  }\n\n  /**\n   * Remove the spectrum from the SpectraProcessor for the specified id\n   * @param {string} id\n   */\n  removeSpectrum(id) {\n    let index = this.getSpectrumIndex(id);\n    if (index === undefined) return undefined;\n    return this.data.splice(index, 1);\n  }\n\n  /**\n   * Returns the index of the spectrum in the spectra array\n   * @param {string} id\n   * @returns {number}\n   */\n  getSpectrumIndex(id) {\n    if (!id) return undefined;\n    for (let i = 0; i < this.data.length; i++) {\n      let spectrum = this.data[i];\n      if (spectrum.id === id) return i;\n    }\n    return undefined;\n  }\n\n  /**\n   * Checks if the ID of a spectrum exists in the SpectraProcessor\n   * @param {string} id\n   */\n  contains(id) {\n    return !isNaN(this.getSpectrumIndex(id));\n  }\n}\n","import Spectrum from '../Spectrum';\nimport addJcamp from '../addJcamp';\n/**\n * Creates a new Chromatogram element based in a JCAMP string\n * @param {string} jcamp - String containing the JCAMP data\n * @param {object} [options={}]\n * @param {object} [options.id=Math.random()]\n * @return {Spectrum} - New class element with the given data\n */\nexport default function fromJcamp(jcamp, options = {}) {\n  let spectrum = new Spectrum(options);\n  addJcamp(spectrum, jcamp);\n  return spectrum;\n}\n","import { convert } from 'jcampconverter';\n\nexport default function addJcamp(spectrum, jcamp) {\n  let converted = convert(jcamp, {\n    keepRecordsRegExp: /.*/,\n    canonicDataLabels: false,\n    dynamicTyping: true,\n  });\n\n  for (let entry of converted.flatten) {\n    let currentSpectrum = entry.spectra[0];\n\n    let xLabel = currentSpectrum.xUnit;\n    let yLabel = currentSpectrum.yUnit;\n\n    let flavor = '';\n    if (xLabel.match(/\\[.*C\\]/)) flavor = 'weightVersusTemperature';\n    if (xLabel.match(/\\[.*s\\]/)) flavor = 'weightVersusTime';\n    if (flavor) {\n      spectrum.set(currentSpectrum.data, {\n        flavor,\n        xLabel,\n        yLabel,\n        title: currentSpectrum.title,\n      });\n    }\n  }\n}\n","import Spectrum from '../Spectrum';\n\nimport parsePerkinElmer from './parsePerkinElmer';\n\n/**\n * Creates a new Chromatogram element based in a JCAMP string\n * @param {string} text - String containing the JCAMP data\n * @return {Spectrum} - New class element with the given data\n */\nexport default function fromPerkinElmer(text) {\n  let spectrum = new Spectrum();\n  let result = parsePerkinElmer(text);\n\n  spectrum.set(\n    { x: result.data.temperature, y: result.data.weight },\n    {\n      xLabel: 'Temperature [°C]',\n      yLabel: 'Weight [mg]',\n      title: result.meta['Sample ID'],\n      meta: result.meta,\n      flavor: 'weightVersusTemperature',\n    },\n  );\n  spectrum.set(result.data.time, result.data.weight, {\n    xLabel: 'Time [s]',\n    yLabel: 'Weight [mg]',\n    title: result.meta['Sample ID'],\n    meta: result.meta,\n    flavor: 'weightVersusTime',\n  });\n  return spectrum;\n}\n","import addStyle from './addStyle';\n\n/**\n * Retrieve a chart with selected original data\n * @param {object} [options={}]\n * @param {Array} [options.ids] List of spectra ids, by default all\n * @param {Array} [options.colors] List of colors\n * @param {Array} [options.flavor]\n * @param {object} [options.normalized]\n */\nexport default function getJSGraph(spectra, options = {}) {\n  let data = spectra.data || spectra;\n  const { ids, colors, flavor, normalized } = options;\n  let chart = {\n    data: [],\n  };\n\n  for (let i = 0; i < data.length; i++) {\n    const spectrum = data[i];\n    if (!ids || ids.includes(spectrum.id)) {\n      let currentData = spectrum.getData({ flavor, normalized });\n      if (!currentData) continue;\n      addStyle(currentData, spectrum, { color: colors[i] });\n      chart.data.push(currentData);\n    }\n  }\n  return chart;\n}\n"],"names":["toString","Object","prototype","object","call","endsWith","_typeof","obj","Symbol","iterator","constructor","sequentialFill","input","arguments","length","undefined","options","isArray","TypeError","_options","_options$from","from","_options$to","to","_options$size","size","step","Error","Math","floor","Array","i","push","_i","normalize","zones","Number","NEGATIVE_INFINITY","POSITIVE_INFINITY","JSON","parse","stringify","map","zone","sort","a","b","forEach","filter","currentZone","result","integral","x0","x1","slope","intercept","equallySpaced","arrayXY","x","y","xLength","reverse","slice","variant","numberOfPoints","exclusions","RangeError","isNaN","exclusion","nextExclusion","invert","unitsPerPoint","reduce","previous","current","currentTotal","min","round","zonesWithPoints","xResult","yResult","zoneResult","processZone","concat","output","halfStep","lastStep","start","max","previousX","MAX_VALUE","previousY","nextX","nextY","frontOutsideSpectra","backOutsideSpectra","currentValue","currentPoints","j","main","equallySpacedSlot","initialOriginalStep","lastOriginalStep","MIN_VALUE","sumAtMin","sumAtMax","add","equallySpacedSmooth","compareNumbers","exports","values","sum","l","arithmeticMean","mul","pow","lnsum","log","means","samples","n","percent","alreadySorted","k","r1","r2","half","unbiased","theMean","mean","theVariance","sqrt","variance","standardDeviation","averageDeviations","abs","stdev","quart","q1","ceil","q2","median","q3","pooledVariance","vari","itemCount","itemArray","count","index","indexOf","maxValue","maxIndex","vector1","vector2","mean1","mean2","cov","s2","s3","dev","m2","g","s4","v","eps","weights","weightedVariance","weightedMean","z","w","inPlace","standardDev","array","isAnyArray","sumValue","norm","_options$algorithm","algorithm","_options$maxValue","toLowerCase","absoluteSumValue","absoluteSum","currentMaxValue","factor","_i2","minValue","rescale","currentMin","currentMax","_options$min","autoMinMax","_options$max","filterX","points","currentFrom","getZones","currentZoneIndex","newX","newY","position","DEFAULT_FLAVOR","Spectrum","id","random","substring","flavors","set","flavor","meta","tmp","xLabel","yLabel","title","standardizeData","get","this","getData","normalization","data","spectrum","filters","console","name","Stat","meanFct","std","stdFct","normed","process","kind","getNormalized","getXLabel","xAxis","getYLabel","yAxis","trim","string","replace","GC_MS_FIELDS","complexChromatogram","spectra","chromatogram","times","series","ms","dimension","existingGCMSFields","label","convertMSFieldToLabel","pageValue","parseFloat","isMSField","canonicDataLabel","value","convertToFloatArray","stringArray","floatArray","fastParseXYData","yFactor","deltaX","isXYdata","currentData","ascii","currentX","firstX","currentY","firstY","endLine","charCodeAt","newLine","isDifference","isLastDifference","lastDifference","isDuplicate","inComment","lastValue","isNegative","inValue","skipFirstValue","decimalPosition","duplicate","ascii2","parsePeakTable","removeCommentRegExp","peakTableSplitRegExp","isPeaktable","lines","split","xFactor","logs","parseXYA","removeSymbolRegExp","isXYAdata","d","e","f","h","c","_ref","module","window","quickSelectMedian","add2D","zData","minZ","maxZ","ySize","xSize","xVector","lastX","lastY","minX","maxX","minY","maxY","noise","getMedian","convertTo3DZ","noContour","contourLines","povarHeight0","povarHeight1","povarHeight2","povarHeight3","isOver0","isOver1","isOver2","isOver3","pAx","pAy","pBx","pBy","lineZValue","nbSubSpectra","nbPovars","dx","y0","dy","iter","nbContourLevels","contourLevels","level","contourLevel","side","noiseMultiplier","exp","zValue","iSubSpectra","subSpectra","subSpectraAfter","povar","segments","generateContourLines","minMax","profiling","action","time","Date","now","simpleChromatogram","intensity","prepareSpectrum","observeFrequency","xUnit","toUpperCase","shiftOffsetVal","shift","ntuplesSeparator","defaultOptions","keepRecordsRegExp","canonicDataLabels","dynamicTyping","xy","withoutXY","keepSpectra","convert","jcamp","assign","wantXY","entriesFlat","entries","tmpResult","children","currentEntry","parentsStack","ldrs","ldr","dataLabel","dataValue","xIndex","yIndex","infos","firstVariable","secondVariable","ntuples","symbol","first","last","vardim","nbPoints","units","yUnit","datatable","parentEntry","info","dataType","twoD","dataClass","xType","indirectFrequency","shiftOffsetNum","varname","vartype","varform","yType","page","pageSymbol","pageSymbolIndex","unit","sampleDescription","pop","match","entry","keys","newNtuples","key","newData","postProcessing","flatten","fromXxyyArray","fromXyxyArray","point","fromXyxyObject","xyConvert","inputFormat","outputFormat","middleData","fromGeneral","toXxyyArray","ans","toXyxyArray","toXyxyObject","fromJSON","owner","origin","type","header","join","creator","getJcamp","addStyle","color","styles","unselected","lineColor","lineWidth","lineStyle","selected","addSpectrum","getSpectrumIndex","removeSpectrum","splice","contains","converted","currentSpectrum","addJcamp","text","weight","temperature","section","inMethodSteps","line","startsWith","description","fields","parsePerkinElmer","ids","colors","normalized","chart","includes","jcamps","weightVersusTemperature","weightVersusTime"],"mappings":"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"}